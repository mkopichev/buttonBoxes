/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include "stm32f103x6.h"

static uint16_t systick_counter = 0;

void delayMs(uint16_t millisec);

int main(void) {

	RCC->CR = (1 << RCC_CR_HSEON_Pos);
	while (!(RCC->CR & (1 << RCC_CR_HSERDY_Pos))) {

		__NOP();
	}
	RCC->CFGR |= (1 << RCC_CFGR_SW_Pos);

	SysTick->LOAD = 8000;
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos)
			| (1 << SysTick_CTRL_CLKSOURCE_Pos)
			| (1 << SysTick_CTRL_TICKINT_Pos);

	RCC->APB2ENR |= (1 << RCC_APB2ENR_IOPCEN_Pos)
			| (1 << RCC_APB2ENR_IOPBEN_Pos) | (1 << RCC_APB2ENR_AFIOEN_Pos);
	RCC->APB1ENR |= (1 << RCC_APB1ENR_TIM2EN_Pos)
			| (1 << RCC_APB1ENR_TIM3EN_Pos);

	// PC13 is a service LED
	GPIOC->CRH |= (2 << GPIO_CRH_MODE13_Pos); // PC13 output, open-drain, speed 2 MHz max

	// button are on PORTB 7, 6, 5 pins
	GPIOB->CRL &= ~((1 << GPIO_CRL_CNF7_Pos) | (1 << GPIO_CRL_CNF6_Pos)
			| (1 << GPIO_CRL_CNF5_Pos)); // clear button pins
	GPIOB->CRL |= (2 << GPIO_CRL_CNF7_Pos) | (2 << GPIO_CRL_CNF6_Pos)
			| (2 << GPIO_CRL_CNF5_Pos); // set button pins as inputs
	GPIOB->ODR |= (1 << GPIO_ODR_ODR7_Pos) | (1 << GPIO_ODR_ODR6_Pos)
			| (1 << GPIO_ODR_ODR5_Pos); // set inputs with pull-up resistors
	EXTI->IMR |= (1 << EXTI_IMR_MR7_Pos) | (1 << EXTI_IMR_MR6_Pos)
			| (1 << EXTI_IMR_MR5_Pos); // interrupts on
	EXTI->FTSR |= (1 << EXTI_FTSR_TR7_Pos) | (1 << EXTI_FTSR_TR6_Pos)
			| (1 << EXTI_FTSR_TR5_Pos);
	AFIO->EXTICR[1] |= (1 << AFIO_EXTICR2_EXTI7_Pos)
			| (1 << AFIO_EXTICR2_EXTI6_Pos) | (1 << AFIO_EXTICR2_EXTI5_Pos); // PORTB 7, 6, 5 interrupt enable
	NVIC_EnableIRQ(EXTI9_5_IRQn);

	// button LEDs are on PORTB 15, 14, 13
	GPIOB->CRH |= (2 << GPIO_CRH_MODE15_Pos) | (2 << GPIO_CRH_MODE14_Pos)
			| (2 << GPIO_CRH_MODE13_Pos);
	GPIOB->CRH &= ~((1 << GPIO_CRH_CNF15_Pos) | (1 << GPIO_CRH_CNF14_Pos)
			| (1 << GPIO_CRH_CNF13_Pos)); // push-pull

	// TIM2 is for buttons debouncing
	TIM2->CR1 |= (1 << TIM_CR1_URS_Pos);
	TIM2->DIER |= (1 << TIM_DIER_UIE_Pos);
	TIM2->PSC = 8000; // timer frequency is 1 kHz
	TIM2->ARR = 20; // timer period is ARR ms
	NVIC_EnableIRQ(TIM2_IRQn);

	// TIM3 is for time delay between buttons pushes
	TIM3->CR1 |= (1 << TIM_CR1_URS_Pos);
	TIM3->DIER |= (1 << TIM_DIER_UIE_Pos);
	TIM3->PSC = 8000; // timer frequency is 1 kHz
	TIM3->ARR = 5000; // timer period is ARR ms
	NVIC_EnableIRQ(TIM3_IRQn);

	for (;;) {

		__NOP();
	}
}

void EXTI9_5_IRQHandler(void) {

	if (EXTI->PR & (1 << EXTI_PR_PR7_Pos)) { // button pressed

		EXTI->PR = (1 << EXTI_PR_PR7_Pos); // clear external interrupt pending
		EXTI->IMR &= ~(1 << EXTI_IMR_MR7_Pos); // disable button interrupt
		TIM2->CR1 |= (1 << TIM_CR1_CEN_Pos); // start timer
		return;
	}
	if (EXTI->PR & (1 << EXTI_PR_PR6_Pos)) {

		EXTI->PR = (1 << EXTI_PR_PR6_Pos);
		EXTI->IMR &= ~(1 << EXTI_IMR_MR6_Pos);
		TIM2->CR1 |= (1 << TIM_CR1_CEN_Pos);
		return;
	}
	if (EXTI->PR & (1 << EXTI_PR_PR5_Pos)) {

		EXTI->PR = (1 << EXTI_PR_PR5_Pos);
		EXTI->IMR &= ~(1 << EXTI_IMR_MR5_Pos);
		TIM2->CR1 |= (1 << TIM_CR1_CEN_Pos);
		return;
	}
}

void TIM2_IRQHandler(void) {

	if (TIM2->SR & (1 << TIM_SR_UIF_Pos)) { // timer overflow occured

		TIM2->SR &= ~(1 << TIM_SR_UIF_Pos); // clear timer overflow interrupt flag
		if (!(GPIOB->IDR & (1 << GPIO_IDR_IDR7_Pos))) { // if button is still pressed after bouncing time

			GPIOB->ODR |= (1 << GPIO_ODR_ODR15_Pos); // light up one of the LEDs
			TIM2->CR1 &= ~(1 << TIM_CR1_CEN_Pos); // stop TIMER2
			TIM3->CR1 |= (1 << TIM_CR1_CEN_Pos); // start TIMER3
			return;
		}
		if (!(GPIOB->IDR & (1 << GPIO_IDR_IDR6_Pos))) {

			GPIOB->ODR |= (1 << GPIO_ODR_ODR14_Pos);
			TIM2->CR1 &= ~(1 << TIM_CR1_CEN_Pos);
			TIM3->CR1 |= (1 << TIM_CR1_CEN_Pos);
			return;
		}
		if (!(GPIOB->IDR & (1 << GPIO_IDR_IDR5_Pos))) {

			GPIOB->ODR |= (1 << GPIO_ODR_ODR13_Pos);
			TIM2->CR1 &= ~(1 << TIM_CR1_CEN_Pos);
			TIM3->CR1 |= (1 << TIM_CR1_CEN_Pos);
			return;
		}
	}
}

void TIM3_IRQHandler(void) {

	if (TIM3->SR & (1 << TIM_SR_UIF_Pos)) {

		TIM3->SR &= ~(1 << TIM_SR_UIF_Pos);
		EXTI->IMR |= (1 << EXTI_IMR_MR7_Pos) | (1 << EXTI_IMR_MR6_Pos)
				| (1 << EXTI_IMR_MR5_Pos); // enable all buttons interrupts
		GPIOB->ODR &= ~((1 << GPIO_ODR_ODR15_Pos) | (1 << GPIO_ODR_ODR14_Pos)
				| (1 << GPIO_ODR_ODR13_Pos)); // turn off all LEDs
	}
}

void delayMs(uint16_t millisec) {

	systick_counter = 0;

	while (systick_counter < millisec) {

		__NOP();
	}
}

void SysTick_Handler(void) {

	if (systick_counter++ > 1000) {

		systick_counter = 0;
		GPIOC->ODR ^= (1 << GPIO_ODR_ODR13_Pos);
	}
}
